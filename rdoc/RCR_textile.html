<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
	"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
	<meta content="text/html; charset=utf-8" http-equiv="Content-Type" />

	<title>File: RCR.textile [Cuts]</title>

	<link type="text/css" media="screen" href="./rdoc.css" rel="stylesheet" />

	<script src="./js/jquery.js" type="text/javascript"
		charset="utf-8"></script>
	<script src="./js/thickbox-compressed.js" type="text/javascript"
		charset="utf-8"></script>
	<script src="./js/quicksearch.js" type="text/javascript"
		charset="utf-8"></script>
	<script src="./js/darkfish.js" type="text/javascript"
		charset="utf-8"></script>
</head>

<body class="file">
	<div id="metadata">
		<div id="project-metadata">
			
			
			<div id="fileindex-section" class="section project-section">
				<h3 class="section-header">Files</h3>
				<ul>
				
					<li class="file"><a href="./HISTORY.html">HISTORY</a></li>
				
					<li class="file"><a href="./LICENSE.html">LICENSE</a></li>
				
					<li class="file"><a href="./RCR_textile.html">RCR.textile</a></li>
				
					<li class="file"><a href="./README.html">README</a></li>
				
					<li class="file"><a href="./RELEASE.html">RELEASE</a></li>
				
					<li class="file"><a href="./Rakefile.html">Rakefile</a></li>
				
				</ul>
			</div>
			

			<div id="classindex-section" class="section project-section">
				<h3 class="section-header">Class Index
					<span class="search-toggle"><img src="./images/find.png"
						height="16" width="16" alt="[+]"
						title="show/hide quicksearch" /></span></h3>
				<form action="#" method="get" accept-charset="utf-8" class="initially-hidden">
				<fieldset>
					<legend>Quicksearch</legend>
					<input type="text" name="quicksearch" value=""
						class="quicksearch-field" />
				</fieldset>
				</form>

				<ul class="link-list">
				
					<li><a href="./Aspect.html">Aspect</a></li>
				
					<li><a href="./Class.html">Class</a></li>
				
					<li><a href="./Cut.html">Cut</a></li>
				
					<li><a href="./Joinpoint.html">Joinpoint</a></li>
				
					<li><a href="./Kernel.html">Kernel</a></li>
				
					<li><a href="./Object.html">Object</a></li>
				
					<li><a href="./Symbol.html">Symbol</a></li>
				
					<li><a href="./Target.html">Target</a></li>
				
				</ul>
				<div id="no-class-search-results" style="display: none;">No matching classes.</div>
			</div>

			
		</div>
	</div>

	<div id="documentation">
		<p>
h1. Cut-base AOP
</p>
<pre>
  by Trans and Peter Vanbroekhoven (rev. 70)
</pre>
<p>
h2. ABSTRACT
</p>
<p>
This RCR presents <em>cut-based</em> AOP, an efficient and easy-to-use
approach to <a href="Aspect.html">Aspect</a> Oriented Programming for Ruby.
</p>
<p>
The work herein is the culmination of multi-year discussion and inquiry on
the topic of AOP for Ruby. It has been carried-out with the ultimate hope
of establishing Ruby as a premier AOP language, if not <em>the</em> AOP
language of choice. Since AOP is a very powerful paradigm for abstracting
programming solutions into <em>separate concerns</em>, and shows great
promise for improvements in <em>code maintenance</em> and
<em>reusability</em>, it seems only natural that an agile language such as
Ruby could provide strong support for this increasing popular pattern of
design.
</p>
<p>
IMPORTANT! This is a new edition of Cut-based AOP and is different from
previous editions. The significant change, is that it simplifies the
definition of a <a href="Cut.html">Cut</a> to it&#8217;s essential
character &#8212;a transparent subclass. The remaining AOP support
structure are transferred to an <a href="Aspect.html">Aspect</a> class,
which is built on top of these pure Cuts.
</p>
<p>
h2. PROBLEM
</p>
<p>
While Ruby&#8217;s meta-programming facilities are powerful enough to allow
for AOP-esque techniques, Ruby&#8217;s lack of any <em>dedicated</em> AOP
support makes it difficult and inefficient to apply <a
href="Aspect.html">Aspect</a> Oriented Programming principles to
application development and makes it practically impossible to do so in any
conventional and thus generally reusable way.
</p>
<p>
h3. Overview of AOP
</p>
<p>
In AOP, one considers <em>aspects of concern</em> applicable across
multiple classes and methods. Thus AOP is said to address
<em>cross-cutting</em> concerns. Aspects consist of <em>advice</em>, which
are methods designed to intercept other methods or events according to
specified criteria. This criteria is called a <em>point-cut</em> and it
designates a set of <em>join-points</em>. A join-point (or
<em>code-point</em>) is the specific place within a program&#8217;s
execution where the advice can be inserted. In this way, AOP is thought to
provide a means of organizing code <b>orthogonal</b> to OOP techniques.
</p>
<p>
<pre>
</p>
<pre>
            ^
            |
       OOP  |   Prob Set.
            |
            +-------------&gt;
                  AOP
</pre>
<p>
</pre>
</p>
<p>
The overall concept is very powerful, but likewise it can be difficult to
integrate into an underlying system, easily succumbing to limitations in
efficiency and subverting the intended ease-of-use and reusability. For
these reasons we believe AOP has not yet become widespread. Our design
addresses these issues.
</p>
<p>
h3. Qualifications for AOP
</p>
<p>
To qualify as an AOP capable language, the following criteria must be given
considerable support:
</p>
<ul>
<li><b>Interception</b>. This is the interjection of advice, adding new
processing into certain locations in a system. The locations are called
join-points, and advice are typically applied to a set of these points, the
point-cut. While there are different types of interception, the most common
by far is method-interception, whereby a method call can be supplemented
before and/or after its execution. This form of interception is the minimum
required of any AOP implementation. In an 100% OOP-based system, it is also
the only form of interception required.

</li>
<li><b>Introduction</b> Where interception is behaviour, introduction is state.
Introduction makes it possible to add further behaviour to an object, but
in contrast to interception, this behaviour is not interleaved with the
existing code, allowing AOP &#8220;modules&#8221; to store there own
specific state.

</li>
<li><b>Inspection</b> It&#8217;s important to have access to as much
&#8220;control&#8221; information about a program as possible, over and
above the normal internal state. In other words, meta-information. Arity is
a good example of this. Other information, like what a method does, what
attributes it modifies, what methods it calls, who calls the method and so
on, to the greatest degree available, all further enhance the capabilities
of AOP.

</li>
<li><b>Modularization</b> Not only must it be possible to intercept, introduce
and inspect, it must also be possible to encapsulate. This encapsulation is
the <em>aspect</em>. Aspects modularize individual cross-cutting concerns
(such as persistence, undo, transactions, locking, caching and so on) into
individual modules; possibly consisting of several sub-aspects, by
delegation, inheritance or composition.

</li>
</ul>
<p>
The above four points are the functional criteria of any implementation of
AOP. In addition there are three major <em>means of implementation</em>:
</p>
<ul>
<li><b>Compile-time Preprocessing</b> With this implementation, advice are
weaved into a program prior to compilation or execution. As such, advice
are akin to macros. This basis of AOP is the most efficient, for obvious
reasons, but is also the least flexible, allowing no alteration based on
runtime data.

</li>
<li><b>Runtime Method Weaving</b> Similar to Compile-time Preprocessing, but
advice intercept methods dynamically at runtime. This itself can be
accomplished in a few ways including simple hooks, subclassing or
delegation. This is typically the most useful implementation of AOP in that
it is both reasonably efficient and flexible.

</li>
<li><b>Runtime Event Tracing</b> In this form callbacks and/or tracing
functions are used to intercept events, or tracepoints. While clearly the
most capable basis of implementation, it also tends to be the least
efficient.

</li>
</ul>
<p>
While the capabilities of these basis largely overlap, they admit of enough
distinctions to justify independent support in accordance to the needs of
the language. The first of these is generally ill suited to a highly
dynamic language like Ruby (although we have recently determined that a
hybrid of the first and last may be feasible), and Ruby already has some
support for the third basis, albeit limited, via set_trace_func, but Ruby
is hampered on the second count. This RCR focuses on the second basis,
which is really the most suitable to a dynamic language like Ruby.
</p>
<p>
h3. Design Principles
</p>
<p>
A mention before getting into the heart of this proposal: The development
of this RCR has been guided by the following two important principles:
</p>
<ul>
<li><b>Consistent and Intuitive</b> The initial spark of this work was the
realization that AOP wrapping is equivalent to anonymous subclassing
(somewhat similar to singleton classes). Utilizing this equivalency offers
advantages in formal design, implementation, syntax and ease of use.

</li>
<li><b>Make the Common Easy, and the Uncommon Possible</b> The vast majority of
advice is applicable to specific classes and method wrap join-points. This
proposal therefore makes these convenient, while still allowing for more
elaborate possibilities.

</li>
</ul>
<p>
h2. PROPOSAL
</p>
<p>
h3. The <a href="Cut.html">Cut</a>
</p>
<p>
The first and foremost requirement of AOP is <em>interception</em>. A few
years ago it occurred to us that subclassing itself is very similar to
interception. The difference was merely a matter of the visibility of the
subclass. With interception, the subclass needed to have its effect
<em>transparently</em>. Indeed, <em>Transparent subclassing is the
fundamental proposition of this RCR.</em> To accomplish it in Ruby we
propose to introduce a new class called the <em>Cut</em>. A <em>cut</em> is
a primitive unit of aspecting. It is used to encapsulate <em>advice for a
single class</em>. Cuts are self-contained units much like classes and
therefore can have their own state (introduction) as well as private
auxiliary methods. Although the <a href="Cut.html">Cut</a> class is very
similar to the <a href="Class.html">Class</a> class, it cannot be
instantiated. Rather it is used solely as an &#8220;invisible
overrider&#8221;. An example will help clarify.
</p>
<p>
Given a class C:
</p>
<p>
<pre>
</p>
<pre>
  class C
    def f(*args); 1; end
    def g(*args); 2; end
  end
</pre>
<p>
</pre>
</p>
<p>
One would normally subclass C in order to gain new functionality.
</p>
<p>
<pre>
</p>
<pre>
  class A &lt; C
    def f
      print '{', super, '}'
    end
  end

  A.new.f  #=&gt; {1}
</pre>
<p>
</pre>
</p>
<p>
But unlike a regular subclass, a cut acts transparently. So we introduce
the &#8216;cut&#8217; construction as follows.
</p>
<p>
<pre>
</p>
<pre>
  cut A &lt; C
    def f
      print '{', super, '}'
    end
  end

  C.new.f  #=&gt; {1}
</pre>
<p>
</pre>
</p>
<p>
Now, even though we have instantiated class C, we have the functional
equivalent of the subclass of C, namely A. Another way of saying this is
that we have <em>cut-across</em> the behaviour of C with A. The cut is
advantageous in its fine control of how advice interact with the
intercepted class and its simple conformity to OOP design. By utilization
of the cut AOP begins to flow naturally into ones programs.
</p>
<p>
Because the <a href="Cut.html">Cut</a> is essentially <a
href="Class.html">Class</a>, like a <a href="Class.html">Class</a> it can
also be defined anonymously, either through instantiation or as a special
singleton. The anonymous definition can be especially convenient for
internal wraps; useful for assertion checks, temporary tests, etc.
</p>
<p>
<pre>
</p>
<pre>
  class C
    def f; 9; end

    Cut.new(self) do
      def f
        '{' + super + '}'
      end
    end
  end

  C.new.f  #=&gt; {9}
</pre>
<p>
</pre>
</p>
<p>
Or through the special singleton form,
</p>
<p>
<pre>
</p>
<pre>
  c = Object.new

  def c.f; 8; end

  cut &lt;&lt; c
    def f
      '{' + super + '}'
    end
  end

  c.f  #=&gt; {8}
</pre>
<p>
</pre>
</p>
<p>
Additionally, Cuts exist in proxy form to allow modules to be
&#8220;premixed&#8221;. This is analogous to proxy classes which allow
modules to mixin to the class hierarchy. So too does a proxy-cut include a
module, albeit preclusive rather the inclusive in its effect. We offer the
module command preclude to serve as designator of this purpose.
</p>
<p>
<pre>
</p>
<pre>
  module A
    def f ; &quot;&lt;#{super}&gt;&quot; ; end
  end

  Class T
    preclude A
    def f ; &quot;okay&quot; ; end
  end

  T.new.f  #=&gt; &quot;&lt;okay&gt;&quot;
</pre>
<p>
</pre>
</p>
<p>
The <a href="Cut.html">Cut</a> class is at the heart of this proposal. The
remaining sections build on this basic device, demonstrating how to use it
for AOP, and offers some important complementary suggestions to make Ruby
more convenient with regard to it and AOP requirements in general.
</p>
<p>
h4. Crosscutting &amp; Targeting
</p>
<p>
A cut is useful for applying advice which intercept the methods of a single
class. But to provide the full advantage of AOP we must also be able to
cut-across multiple classes. The simplest means of cross-cutting is by use
of a shared module. A shared module can serve as a simple <em>aspect</em>
by its inclusion in a cut for each class.
</p>
<p>
<pre>
</p>
<pre>
  class C
    def f; 'C'; end
  end

  class D
    def f; 'D'; end
  end

  module A
    def f
      '{' + super + '}'
    end
  end

  cut Ac &lt; C ; include A ; end
  cut Ad &lt; D ; include A ; end

  C.new.f  #-&gt; {C}
  D.new.f  #-&gt; {D}
</pre>
<p>
</pre>
</p>
<p>
Using a cut, advice intercept methods of the same name and use super to
call back to those methods &#8212;the basics of subclassing. But for advice
to be fully reusable it must be possible to designate alternate
method-to-advice mapping. The simplest way to do this is by calling
secondary methods, as one might normally do within a class.
</p>
<p>
<pre>
</p>
<pre>
  cut A &lt; C
    def f
      bracket
    end
    def g
      bracket
    end
    def bracket
      '{' + super + '}'  # PROBLEM!
    end
  end
</pre>
<p>
</pre>
</p>
<p>
But notice the problem that arises. Super will not be directed to
<tt>f</tt> or <tt>g</tt> in class C, but to <tt>bracket</tt> which
isn&#8217;t defined in C. This is not the desired result. A presently
possible way to correct this is to pass a closure on the super call of the
<em>target method</em>.
</p>
<p>
<pre>
</p>
<pre>
  cut A &lt; C
    def f
      bracket( lambda{super} )
    end
    def g
      bracket( lambda{super} )
    end
    def bracket( target )
      '{' + target.call + '}'
    end
  end
</pre>
<p>
</pre>
</p>
<p>
This works well enough, though one must be careful to avoid name clashes
between advice and methods in classes being cut, but it is a rather
brutish; nor does it provide any significant <em>inspection</em>. We can
improvement upon this by passing the target method itself, but
<em>enhanced</em> to provide the current super context, and usefully, its
own name. We might define a method to provide this with something like:
</p>
<pre>
  def target_method(name,&amp;block)
    m = method(name)
    m.send(:define_method, :name, name)
    m.send(:define_method, :super, &amp;block)
    m
  end
</pre>
<p>
Then we can use it as follows.
</p>
<p>
<pre>
</p>
<pre>
  cut A &lt; C
    def f
      bracket( target(:f){super} )
    end
    def g
      bracket( target(:g){super} )
    end
    def bracket( target )
      puts 'Advising #{target.name}...'
      '{' + target.super + '}'
    end
  end
</pre>
<p>
</pre>
</p>
<p>
This technique may be common enough to warrant the introduction of a
keyword just for the purpose, perhaps the term <tt>this</tt> would be a
good choice. With &#8220;this&#8221; in place, the above example can be
nicely simplified.
</p>
<p>
<pre>
</p>
<pre>
  cut A &lt; C
    def f
      bracket( this )
    end
    def g
      bracket( this )
    end
    def bracket( target )
      puts 'Advising #{target.name}...
      '{' + target.super + '}'
    end
  end
</pre>
<p>
</pre>
</p>
<p>
The special call this could also carry a method&#8217;s call parameters and
block if given; it could even be queried as <tt>this.block_given?</tt>.
</p>
<p>
h4. Limitations of Cuts
</p>
<p>
At this point we reached the extent to which Cuts can provide AOP. Cuts are
a robust technique provide <em>unit-AOP</em>, ie. per-class interception.
This is a powerful tool applicabe to many uses cases. However, to go
further we need to look at the two limitations of cuts.
</p>
<p>
FIRST. Advising multiple methods with a single advice, as we have done in
the above examples, is a common case of AOP, a convenient means of
redirecting target methods to advice is essential. It is trivial to define
a method like the following <tt>Cut#redirect_advice</tt>:
</p>
<p>
<pre>
</p>
<pre>
  class Cut
    def redirect_advice( h )
      c = h.collect { |k,v|
        &quot;def #{k}(*a,&amp;b) #{v}(this,*a, &amp;b); end&quot;
      }
      module_eval c.join(&quot;\n&quot;)
    end
  end

  cut A &lt; C
    redirect_advice :f =&gt; :bracket, :g =&gt; :bracket
    def bracket( target )
      '{' + target.super + '}'
    end
  end
</pre>
<p>
</pre>
</p>
<p>
However, it not sufficient for dealing with Ruby&#8217;s dynamicism. It
will only handles methods defined in the target class at the moment the cut
is defined. Complete AOP support requires the advice always stay in sync
even under dynamic alteration of the targeted class. Ruby already provides
means for this via the Module#method_added hook, but robust use of this
technique is inconvenient at best. So a proper advice-oriented techinique
is neede
</p>
<p>
SECOND. When using redirected advice or, more importantly, when using
modules as reusable aspects: care must be taken in choosing method names so
as not to inadvertently interfere with the methods of the class(es) being
cut. This can be a problem because it inhibits code reuse, i.e. the ability
to design components without regard to where they may be applied. For
example:
</p>
<p>
<pre>
</p>
<pre>
  class C
    def m ; &quot;M&quot; ; end
    def w ; &quot;W&quot; ; end
    def d ; w ; end
  end

  module MA
    def w( target )
      '{' + target.super + '}'
    end
  end

  cut A &lt; C
    include MA
    def m ; w( this ) ; end
  end

  C.new.d  #=&gt; &quot;{W}&quot;
</pre>
<p>
</pre>
</p>
<p>
In this case, d does not return &#8220;W&#8221; as expected, but rather
&#8220;{W}&#8221; because the advice in MA caused an unexpected name clash
with the w method in C. To fulfil the true abstraction and re-usability
potential of AOP this issue <em>must</em> be remedied.
</p>
<p>
One remedy comes from Ruby&#8217;s ability to dynamically manipulate
class/module definitions on the fly, in other words,
&#8220;sub-classing&#8221; the aspect module and applying any required name
revisions to avoid the unwanted name clash.
</p>
<p>
<pre>
</p>
<pre>
  class C
    def m ; &quot;M&quot; ; end
    def w ; &quot;W&quot; ; end
    def d ; w ; end
  end

  module MA
    def w( target )
      '{' + target.super + '}'
    end
  end

  module MArC
    include MA
    rename_method :q, :w
  end

  cut A &lt; C
    include MArC
    def m ; q( this ) ; end
  end
</pre>
<p>
</pre>
</p>
<p>
The @rename_method@ effectively alias the original method and undefines it
in one call. This solves the clash problem in a very controllable way,
which is nice. We can even make it more convenient by defining some helper
traits like methods. For instance:
</p>
<p>
<pre>
</p>
<pre>
  cut A &lt; C
    include MA * { :q =&gt; :w }
    def m ; q( this ) ; end
  end
</pre>
<p>
</pre>
</p>
<p>
This kind of solution largely address the name clash issue, but it is still
less then optimal.
</p>
<p>
h3. The <a href="Aspect.html">Aspect</a>
</p>
<p>
To address the limitation of the <a href="Cut.html">Cut</a>, we take the
next natural step in supporting AOP and create the <a
href="Aspect.html">Aspect</a>. Aspects are similar to Cuts, in fact they
can be built via delegation to Cuts, but they are a higher-level structure
and support all the AOP features most are accustom, such a pointcuts,
join-points and multi-class cross-cutting. An <a
href="Aspect.html">Aspect</a> basically takes the <a
href="Cut.html">Cut</a> class, builds-in all the target features we handled
by hand in Cuts, adds flow control methods for handling Ruby&#8217;s
dynamicism and provides a wholly separate area of encapsulation, which
avoids any name clashing.
</p>
<p>
The primary distinction of Aspects is the join method, which identifies
which methods are to be advised but what advice.
</p>
<p>
<pre>
</p>
<pre>
  class C
    def f ; &quot;F&quot; ; end
    def g ; &quot;G&quot; ; end
  end

  aspect A
    join :f =&gt; :bracket, :g =&gt; :bracket
    def bracket( target )
      '{' + target.super + '}'
    end
  end

  A.apply_to(C)
</pre>
<p>
</pre>
</p>
<p>
The join method would also accept wild cards.
</p>
<p>
<pre>
</p>
<pre>
  aspect A
    join '*' =&gt; :bracket
    def bracket( target )
      '{' + target.super + '}'
    end
  end
</pre>
<p>
</pre>
</p>
<p>
An it can also take a block which allows us to work with join-points. In
the code below, @jp@ is a JoinPoint object.
</p>
<pre>
  Xa = Aspect.new do
    join :x do |jp|
      jp.name == :f or jp.name == :g
    end

    def x(target); '{' + target.super + '}'; end
  end
</pre>
<p>
A JoinPoint object is very similar to an internal Ruby frame, and provides
parameters based on the targeted method plus many of the same parameters
that set_trace_func can use: event, file, line, id, binding, classname.
Though some of these may be omitted for performance reasons.
</p>
<p>
We don&#8217;t necessarily need Aspects to cross-cut large swaths of
classes. Ruby&#8217;s built-in reflexion provides means via ObjectSpace.
</p>
<p>
<pre>
</p>
<pre>
  ObjectSpace.each_object(Class) { |c|
    if c.instance_methods(false).include?(:to_s)
      Cut.new(c) do
        def :to_s
          super.upcase + &quot;!&quot;
        end
      end
    end
  end

  &quot;a lot of shouting for joy&quot;.to_s  #=&gt; &quot;A LOT OF SHOUTING FOR JOY!&quot;
</pre>
<p>
</pre>
</p>
<p>
However system-wide effects must by definition be more robust as we
can&#8217;t always account for the nature of each class. So Aspects are
much more appropriate to this use. To facilitate this, Aspects offer the
pointcut method.
</p>
<p>
<pre>
</p>
<pre>
  aspect A
    join :to_s =&gt; :to_s
    def to_s(target)
      target.super.upcase + &quot;!&quot;
    end
  end

  A.pointcut do |pc|
    true if pc.instance_methods(false).include?(:to_s)
  end
</pre>
<p>
</pre>
</p>
<p>
There are plenty of great applications for broad cross-cutting like this,
especially in the way of code inspection, unit testing, debugging, etc. The
<a href="Aspect.html">Aspect</a> is a vital part to AOP as it provides the
dynamic flexibility that is required of complete Ruby AOP solution.
</p>
<p>
h2. ANALYSIS
</p>
<p>
The <a href="Cut.html">Cut</a> and its supporting infrastructure as
described above is designed to be a very robust, easy to use, and
efficient, providing better overall AOP support than any other language
presently in common use.
</p>
<p>
In contrast, the traditional approach taken by the most AOP systems today,
largely propagated by early implementations like Aspect/J, have proven
unwieldy and ironically end-up inhibiting code reuse. Infact, the limited
reusabiliy has been speculated elsewhere as a potential primary culprit in
the limited penetration of AOP to date. This proposal circumvents these
issues by offering a general solution directly integrated into the OOP
system, rather than attempting to operate wholly beyond it.
</p>
<p>
Cuts also trump simple method-wrapping mechanisms, like those proposed in
Matz&#8217; RUbyConf 2004 presentation. While method hooks are especially
convenient, they are weak with regards to SOC (Separation Of Concerns);
most notably, method hooks lack <em>introduction</em> altogether. They also
suffer from order of execution ambiguities that must be dealt with by
imposing limitations or adding increasingly specialized declarations. Cuts
again circumvent these issues by utilizing an inherent OOP construct
&#8212;the subclass, rather than adding on a new, wholly
&#8220;other&#8221; entity.
</p>
<p>
h3. Pros
</p>
<ul>
<li>Provides a robust method-wrapping solution, devoid of order ambiguities.

</li>
<li>Clear separation of concerns using separate cuts and modular aspects.

</li>
<li>Based on standard OOP devices, i.e. cuts are essentially subclasses.

</li>
<li>Cut-based AOP is very easy to understand and thus to use.

</li>
<li>Implementation is efficient.

</li>
</ul>
<p>
h3. Cons
</p>
<ul>
<li><a href="Cut.html">Cut</a> syntax is a slightly more verbose and entails
more overhead than simple method hooks. [Counterpoint: But the difference
<em>is</em> minor. Simple methods hooks could, in point of fact, be
implemented via cuts with efficiencies quite close to a simple hook
solution.]

</li>
<li>Cannot advise large numbers of classes in a single <em>dedicated</em>
clause. [Counterpoint: Cuts are specifically designed <em>not</em> to do
this as the inability also has advantage, not the least of which is
performance efficiency. Moreover it has been discovered that such large
swaths of cross-cutting are in actuality the uncommon usecases, more
suitable to specialized applications like unit-testing and profiling.]

</li>
<li>AOP traditionalists might be a bit taken aback by the Cut-based approach in
that it does not specifically reference join-points and pointcuts.
[Counerpoint: As above, cuts provide a better approach for the most common
AOP usecases.]

</li>
<li>Until local instance variables are available, and/or local instance
methods, <em>introduction</em> is not as strong as it really needs to be
for good AOP coverage. [Counterpoint: We suspect this is likely to be
addressed in a future version of Ruby.]

</li>
</ul>
<p>
h2. IMPLEMENTAITON
</p>
<p>
One implementation detail, not specifically decided by this proposal, is
whether cuts may or may not be applied to other cuts. If not allowed, once
a cut is applied to a class, a subsequent cut can not be slipped in between
it and that class. Cuts are intended to work transparently and offering
this feature could thwart this principle. On the other hand, if allowed, it
would provided a means for a cut to &#8220;underwrite&#8221; another cut
providing greater flexibility in &#8220;meta&#8221;-controlling the effects
of cuts.
</p>
<p>
Another implementation detail to consider that falls outside the strict
scope of this proposal, but that goes a long way toward bolstering it, is
the limits on <em>introduction</em> due to the non-locality of instance
variables and methods. Presently cuts will only be able to provide
introduction through class varaibles &#8212;useful but weak by comparision.
With the advent of locals in a future version of Ruby, cuts would gain
robust introduction strengths.
</p>
<p>
The first real step in implementation is, of course, the creation of the
transparent subclass, the <a href="Cut.html">Cut</a>. This requires an
addition in the structure of an object&#8217;s class hierarchy; essentially
a new pointer to a chain of cuts, the last pointing back at the cut class
itself &#8212;a very simpleton explanation to be sure. But fortunately, a
well written Ruby patch has been coded by Peter Vanbroekhoven. It
implements most of the core funtionality described here, and should serve
as a means to investigate and test the potential utility of this RCR. It
may also serve as a basis for including these AOP features into Ruby
proper, should this RCR be accepted. At this time the patch applys to Ruy
1.8.2 and can be download from
&#8220;here&#8221;:HTTP://rubyforge.org/projects/suby/ under
&#8220;transparent subclass (cut)&#8221;.
</p>

	</div>

	<div id="validator-badges">
		<p><small><a href="http://validator.w3.org/check/referer">[Validate]</a></small></p>
		<p><small>Generated with the <a href="http://deveiate.org/projects/Darkfish-Rdoc/">Darkfish
			Rdoc Generator</a> 1.1.6</small>.</p>
	</div>
</body>
</html>

